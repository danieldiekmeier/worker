"use strict";(self.webpackChunkgraphile_worker=self.webpackChunkgraphile_worker||[]).push([[377],{5318:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var n=a(7378);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),l=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},c="mdxType",y={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=l(a),u=r,m=c["".concat(p,".").concat(u)]||c[u]||y[u]||o;return a?n.createElement(m,i(i({ref:t},d),{},{components:a})):n.createElement(m,i({ref:t},d))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=a[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},147:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>y,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var n=a(5773),r=(a(7378),a(5318));const o={title:"TypeScript",sidebar_position:65},i=void 0,s={unversionedId:"typescript",id:"typescript",title:"TypeScript",description:"Graphile Worker is written in TypeScript. By default, for safety, payloads are",source:"@site/docs/typescript.md",sourceDirName:".",slug:"/typescript",permalink:"/docs/typescript",draft:!1,editUrl:"https://github.com/graphile/worker/tree/main/website/docs/typescript.md",tags:[],version:"current",sidebarPosition:65,frontMatter:{title:"TypeScript",sidebar_position:65},sidebar:"tutorialSidebar",previous:{title:"Database schema",permalink:"/docs/schema"},next:{title:"Adding jobs through SQL",permalink:"/docs/sql-add-job"}},p={},l=[{value:"<code>GraphileWorker.Tasks</code>",id:"graphileworkertasks",level:2},{value:"Using type guards",id:"using-type-guards",level:2}],d={toc:l},c="wrapper";function y(e){let{components:t,...a}=e;return(0,r.kt)(c,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Graphile Worker is written in TypeScript. By default, for safety, ",(0,r.kt)("inlineCode",{parentName:"p"},"payload"),"s are\ntyped as ",(0,r.kt)("inlineCode",{parentName:"p"},"unknown")," since they may have been populated by out of date code, or\neven from other sources. This requires you to add a type guard or similar to\nensure the ",(0,r.kt)("inlineCode",{parentName:"p"},"payload")," conforms to what you expect. It can be convenient to\ndeclare the payload types up front to avoid this ",(0,r.kt)("inlineCode",{parentName:"p"},"unknown"),", but doing so might\nbe unsafe - please be sure to read the caveats below."),(0,r.kt)("h2",{id:"graphileworkertasks"},(0,r.kt)("inlineCode",{parentName:"h2"},"GraphileWorker.Tasks")),(0,r.kt)("p",null,"You can register types for Graphile Worker tasks using the following syntax in a\nshared TypeScript file in your project:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'declare global {\n  namespace GraphileWorker {\n    interface Tasks {\n      // <name>: <payload type>; e.g.:\n      myTaskIdentifier: { details: "are"; specified: "here" };\n    }\n  }\n}\n')),(0,r.kt)("p",null,"This should then enable auto-complete and payload type safety for ",(0,r.kt)("inlineCode",{parentName:"p"},"addJob")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"quickAddJob"),", and should also allow the payloads of your task functions to be\ninferred when defined like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const task: Task<"myTaskIdentifier"> = async (payload, helpers) => {\n  const { details, specified } = payload;\n  /* ... */\n};\n')),(0,r.kt)("p",null,"or like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const tasks: TaskList = {\n  async myTaskIdentifier(payload, helpers) {\n    const { details, specified } = payload;\n    /* ... */\n  },\n};\n")),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"Using TypeScript types like this can be misleading. Graphile Worker jobs can be\ncreated in the database directly via the ",(0,r.kt)("inlineCode",{parentName:"p"},"graphile_worker.add_job()")," or\n",(0,r.kt)("inlineCode",{parentName:"p"},".add_jobs()")," APIs; and these APIs cannot check that the payloads added conform\nto your TypeScript types. Further, you may modify the payload type of a task in\na later version of your application, but existing jobs may exist in the database\nusing the old format. This can lead to you assuming that something is a number\nwhen actually it's ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", resulting in more bugs in your code, so care must be\ntaken."),(0,r.kt)("p",{parentName:"admonition"},"We recommend you use type guards instead.")),(0,r.kt)("h2",{id:"using-type-guards"},"Using type guards"),(0,r.kt)("p",null,"To ensure your system is as safe as possible (and guard against old jobs, or\njobs specified outside of TypeScript's type checking) we recommend that you use\ntype guards to assert that your payload is of the expected type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'interface MyPayload {\n  username: string;\n}\n\nfunction assertMyPayload(payload: any): asserts payload is MyPayload {\n  if (\n    typeof payload === "object" &&\n    payload &&\n    typeof payload.username === "string"\n  ) {\n    return;\n  }\n  throw new Error("Invalid payload, expected a MyPayload");\n}\n\nconst task: Task = async (payload) => {\n  assertMyPayload(payload);\n  console.log(payload.username);\n};\n')),(0,r.kt)("p",null,"If this is too manual, you might prefer to use a library such as ",(0,r.kt)("inlineCode",{parentName:"p"},"runtypes")," or\nthe many others of a similar ilk. If you're not concerned with the type safety\nof the payload, you can work around it with a couple casts:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const task: Task = (inPayload) => {\n  const payload = inPayload as any as MyPayload;\n};\n")))}y.isMDXComponent=!0}}]);